# Checkers  

## 逻辑流程验证

### 棋盘初始化
在Board构造函数中按规则初始化pieces的坐标与颜色  
调用draw()绘制初始界面（使用EasyX的fillpolygon绘制六边形）

### 鼠标交互

玩家点击棋子：  
遍历pieces判断点击位置，若为当前玩家棋子，调用calculateMoves计算路径  
高亮显示棋子及validMoves中的可移动位置

玩家点击目标位置：  
若坐标在validMoves中，调用movePiece更新棋子坐标  
若触发胜利条件，弹出结束提示，否则切换currentPlayer

移动合法性校验  
单步移动：检查目标位置是否为空且为相邻六边形（坐标差绝对值≤1）  
跳跃移动：递归检测中间棋子的对角位置是否为空，支持连续跳跃（通过队列实现BFS路径搜索）

胜负判断  
遍历当前玩家的所有棋子，检查是否全部位于对方初始区域（如红方需全部到达y≥9的行）

难点预警：  
连续跳跃的路径搜索需结合队列实现BFS算法，需提供算法支持。

### 下棋逻辑  
由棋盘维护、记录所有棋子的所有信息，玩家只记录自己对应的颜色  

当游戏管理类接受鼠标信号后，调用棋盘的方法，判断该位置有没有棋子  
（为什么这里的由游戏管理类控制？因为按下的位置可能是退出等其他按钮）  

若有，则使用玩家实例，利用玩家的方法检测这个棋子的颜色和自己的颜色是不是匹配  

如果是自己的棋子，返回true，随后由棋盘调取自己的移动棋子方法，控制权移交棋盘  
（随后所有检测信息直接给棋盘），  
直到棋子完成合法移动，更新自身状态，重新绘制棋盘